# This file contains the fastlane.tools configuration
# You can find the documentation at https://docs.fastlane.tools
#
# For a list of all available actions, check out
#
#     https://docs.fastlane.tools/actions
#
# For a list of all available plugins, check out
#
#     https://docs.fastlane.tools/plugins/available-plugins
#

# Uncomment the line if you want fastlane to automatically update itself
# update_fastlane

# https://www.runway.team/blog/how-to-set-up-a-ci-cd-pipeline-for-your-ios-app-fastlane-github-actions

default_platform(:ios)

require 'plist'

platform :ios do
  def sentry_upload_build_filtered(**params)
    filtered_params = params.select { |key, value|
      value && !value.to_s.strip.empty?
    }
    sentry_upload_build(**filtered_params)
  end

  desc 'Load ASC API Key information to use in subsequent lanes'
  lane :load_asc_api_key do
    app_store_connect_api_key(
      key_id: ENV['ASC_KEY_ID'],
      issuer_id: ENV['ASC_ISSUER_ID'],
      key_content: ENV['ASC_KEY'],
      is_key_content_base64: false,
      in_house: false # Detecting this via ASC private key not currently supported
    )
  end

  desc 'Generate build number based on number of commits'
  lane :generate_build_number do
    # Deterministically set the build number based on the number of commits
    build_number = number_of_commits()

    increment_build_number(
      build_number: build_number
    )
  end

 desc 'Installs signing certificate in the keychain and downloads provisioning profiles from App Store Connect'
 lane :prepare_signing do |options|
   team_id = CredentialsManager::AppfileConfig.try_fetch_value(:team_id)
   api_key = lane_context[SharedValues::APP_STORE_CONNECT_API_KEY]
   app_identifier = CredentialsManager::AppfileConfig.try_fetch_value(:app_identifier)
   bundle_identifier = ENV['BUNDLE_ID'] || app_identifier

   keychain_name = 'signing'
   keychain_password = 'temp'

   delete_keychain(
     name: keychain_name
   ) if File.exist? File.expand_path("~/Library/Keychains/#{keychain_name}-db")

   create_keychain(
     name: keychain_name,
     password: keychain_password,
     default_keychain: true,
     unlock: true,
     timeout: 3600
   )

   import_certificate(
     certificate_path: ENV['SIGNING_KEY_FILE_PATH'],
     certificate_password: ENV['SIGNING_KEY_PASSWORD'],
     keychain_name: keychain_name,
     keychain_password: keychain_password
   )

    [true, false].each do |adhoc|
      profile_name = adhoc ? 'HackerNews AdHoc Distribution' : 'Github'
      widget_profile_name = adhoc ? 'HackerNews AdHoc HomeWidget' : 'HackerNewsHomeWidget Distribution'
      # Fetches and installs provisioning profiles from ASC
      sigh(
        adhoc: adhoc,
        api_key: api_key,
        readonly: true,
        provisioning_name: profile_name,
        app_identifier: bundle_identifier
      )
      sigh(
        adhoc: adhoc,
        api_key: api_key,
        readonly: true,
        provisioning_name: widget_profile_name,
        app_identifier: 'com.emergetools.hackernews.HackerNewsHomeWidget'
      )
    end
  end

  desc 'Build the iOS app'
  lane :build_app_for_scheme do |options|
    app_identifier = CredentialsManager::AppfileConfig.try_fetch_value(:app_identifier)
    bundle_identifier = ENV['BUNDLE_ID'] || app_identifier

    profile_name = ENV['PROV_PROFILE_NAME'] || 'Github'
    adhoc = ENV['ADHOC'] === 'true'
    widget_profile_name = ENV['WIDGET_PROV_PROFILE_NAME'] || 'HackerNewsHomeWidget Distribution'
    output_name = 'hackernews-iOS' # .ipa name
    export_method = 'app-store'

    # Turn off automatic signing during build so correct code signing identity is guaranteed to be used
    update_code_signing_settings(
      use_automatic_signing: false,
      targets: ['HackerNews', 'HackerNewsHomeWidgetExtension'],
      code_sign_identity: 'Apple Distribution',
      bundle_identifier: bundle_identifier,
      profile_name: profile_name,
      build_configurations: [ENV['CONFIGURATION']],
      team_id: ENV['APPLE_TEAM_ID']
    )

    # Also update code signing for widget extension specifically
    update_code_signing_settings(
      use_automatic_signing: false,
      targets: ['HackerNewsHomeWidgetExtension'],
      code_sign_identity: 'Apple Distribution',
      bundle_identifier: 'com.emergetools.hackernews.HackerNewsHomeWidget',
      profile_name: widget_profile_name,
      build_configurations: [ENV['CONFIGURATION']],
      team_id: ENV['APPLE_TEAM_ID']
    )

    # build the app
    build_ios_app(
      scheme: 'HackerNews',
      output_name: output_name,
      configuration: ENV['CONFIGURATION'],
      export_team_id: ENV['APPLE_TEAM_ID'],
      skip_package_ipa: true,
      archive_path: './build/HackerNews.xcarchive',
      export_options: {
        method: export_method,
        provisioningProfiles: {
          bundle_identifier => profile_name,
          'com.emergetools.hackernews.HackerNewsHomeWidget' => widget_profile_name
        },
        team_id: ENV['APPLE_TEAM_ID']
      }
    )
  end

  desc 'Upload to TestFlight / ASC'
  lane :upload_app do
    api_key = lane_context[SharedValues::APP_STORE_CONNECT_API_KEY]

    deliver(
      api_key: api_key,
      skip_screenshots: true,
      skip_metadata: true,
      skip_app_version_update: true,
      force: true, # Skips verification of HTML preview file (since this will be run from a CI machine)
      run_precheck_before_submit: false # Not supported through ASC API yet
    )
  end

  desc 'Build and upload to TestFlight + Emerge Tools'
  lane :build_upload_testflight do
    load_asc_api_key
    prepare_signing
    generate_build_number
    build_app_for_scheme
    upload_app
    emerge(tag: ENV['EMERGE_BUILD_TYPE'])
    export_thinned_build
    sentry_debug_files_upload(
      auth_token: ENV['SENTRY_AUTH_TOKEN'],
      org_slug: 'emerge-tools',
      project_slug: 'hackernews-ios',
      include_sources: true
    )
    sentry_upload_build_filtered(
      auth_token: ENV['SENTRY_SENTRY_AUTH_TOKEN'],
      org_slug: 'sentry',
      project_slug: 'launchpad-test-ios',
      build_configuration: 'Release',
      log_level: 'debug'
    )
  end

  desc 'Build and upload to Emerge Tools'
  lane :build_upload_emerge do
    load_asc_api_key
    prepare_signing
    build_app_for_scheme
    emerge(
      tag: ENV['EMERGE_BUILD_TYPE'],
      app_id_suffix: ENV['APP_ID_SUFFIX']
    )
    export_thinned_build
    sentry_upload_build_filtered(
      auth_token: ENV['SENTRY_SENTRY_AUTH_TOKEN'],
      org_slug: 'sentry',
      project_slug: 'launchpad-test-ios',
      build_configuration: ENV['CONFIGURATION'],
      log_level: 'debug'
    )
  end

  desc 'Build and upload snapshot build to Emerge Tools'
  lane :build_upload_emerge_snapshot do
    emerge_snapshot(scheme: "HackerNews")
  end

  desc 'Export thinned build for specific device type'
  lane :export_thinned_build do |options|
    xcarchive_path = lane_context[SharedValues::XCODEBUILD_ARCHIVE]
    UI.message("Using archive: #{xcarchive_path}")
    
    # Device type configuration for thinning, default is iPhone 16 Pro
    device_type = options[:device_type] || 'iPhone17,1'
    UI.message("Thinning for device type: #{device_type}")
    
    # Export options for thinning
    export_options = {
      method: 'ad-hoc',
      thinning: device_type,  # This creates a thinned build for the specific device type
      team_id: ENV['APPLE_TEAM_ID']
    }
    
    # Add provisioning profiles if available
    app_identifier = CredentialsManager::AppfileConfig.try_fetch_value(:app_identifier)
    bundle_identifier = ENV['BUNDLE_ID'] || app_identifier
    profile_name = 'HackerNews AdHoc Distribution'
    widget_profile_name = 'HackerNews AdHoc HomeWidget'
    
    export_options[:provisioningProfiles] = {
      bundle_identifier => profile_name,
      'com.emergetools.hackernews.HackerNewsHomeWidget' => widget_profile_name
    }

    Dir.chdir("..") do
      File.open('export_options.plist', 'w') do |file|
        file.write(Plist::Emit.dump(export_options))
      end
      xcsafe = File.join(Gym::ROOT, "lib/assets/wrap_xcodebuild/xcbuild-safe.sh")
      sh("#{xcsafe} -exportArchive -archivePath #{xcarchive_path} -exportOptionsPlist export_options.plist -exportPath ./build")

      plist_data = Plist.parse_xml('./build/app-thinning.plist')
      
      # Find the variant matching our device and OS version
      target_ipa_path = nil
      
      if plist_data && plist_data['variants']
        plist_data['variants'].each do |variant|
          path = variant[0]
          descriptors = variant[1]['variantDescriptors']
          descriptors.each do |descriptor|
            if descriptor['device'] == device_type && descriptor['os-version'] == '18.0'
              target_ipa_path = path
              break
            end
          end
        end
      end
      
      ipa_path = File.join('../', target_ipa_path)
      UI.message("Using IPA: #{ipa_path}")
      
      temp_dir = './build/temp_extraction'
      FileUtils.rm_rf(temp_dir) if Dir.exist?(temp_dir)
      FileUtils.mkdir_p(temp_dir)
      
      # Extract the IPA
      sh("cd #{temp_dir} && unzip -q '#{ipa_path}'")
      payload_dir = File.join(temp_dir, 'Payload')
      app_files = Dir.glob(File.join(payload_dir, '*.app'))
      
      if app_files.empty?
        UI.error("No .app file found in extracted IPA")
        return
      end
      
      thinned_app_path = app_files.first
      # Find the original .app in the XCArchive
      original_app_pattern = File.join(xcarchive_path, 'Products', 'Applications', '*.app')
      original_app_files = Dir.glob(original_app_pattern)
      
      original_app_path = original_app_files.first
   
      FileUtils.rm_rf(original_app_path)
      FileUtils.cp_r(thinned_app_path, original_app_path)
      
      # Clean up temporary directory
      FileUtils.rm_rf(temp_dir)
    end
    
    UI.success("Successfully replaced app in XCArchive with thinned build for #{device_type}")
  end

  desc 'Build the iOS app only (no uploads)'
  lane :build_only do
    load_asc_api_key
    prepare_signing
    generate_build_number
    build_app_for_scheme(build_configuration: ENV['CONFIGURATION'] || 'Release')
  end
end
